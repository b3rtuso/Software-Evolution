<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chapter 9 Software Evolution</title>
    
    <link href="src/output.css" rel="stylesheet" />
  </head>
  <body class="bg-gray-50">


    <nav class="bg-gray-900 fixed w-full top-0 left-0">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
          
 
          <a href="home.html" class="text-2xl font-bold text-white">Software Evolution</a>
  

          <ul class=" text-base font-semibold hidden md:flex space-x-8">
            <li><a href="home.html" class="text-white hover:text-blue-300">Home</a></li>
            <li><a href="9.1.html" class="text-white hover:text-blue-300"> Processes</a></li>
            <li><a href="lawrence.html" class="text-white hover:text-blue-300">Program Dynamics</a></li>
            <li><a href="index.html" class="text-white hover:text-blue-300">Legacy System Management</a></li>
          </ul>
        </div>
      </div>
    </nav>
    
   <main class="max-w-4xl mx-auto p-6 mt-20">
  <header class="mb-10 text-center">
    <h1 class="text-4xl font-bold mb-2">Program Dynamics</h1>
    <p class="text-gray-600 dark:text-gray-400 text-sm">Chapter 9 · Updated October 2025</p>
  </header>

    <!-- Main Content Section -->
   <div class="pt-20"></div><main class="max-w-6xl mx-auto px-6 py-8 text-justify">
    <section id="program-evolution" class="mb-10">
      <article>
        <h2 class="text-2xl font-semibold mb-4">9.2 Program Evolution Dynamics</h2>
        <p>Program evolution dynamics studies system change. In the 1970s and 1980s, Lehman and Belady researched system change to understand software evolution. Their work continued in the 1990s, focusing on feedback in evolution processes. This led to the proposal of ‘Lehman’s laws’ on system change.</p>
        <p class="mt-3">Lehman and Belady believed these laws apply to all large organizational software systems (E-type systems), where requirements change with business needs. New releases are crucial for business value.</p>
      </article>
    
        <section id="software-maintenance" class="mb-10">
      <article>
        <h2 class="text-2xl font-semibold mb-4">9.3 Software Maintenance</h2>
        
        <p>Software maintenance involves modifying a system after delivery. Changes may fix errors, adapt the system, or add new functionality. This is done by modifying existing components or adding new ones.</p>


       <section> 
        <h2 class="text-xl font-semibold mt-6 mb-2">Types of Software Maintenance</h2>
        <ol class="list-decimal list-inside space-y-2">
          <li><strong>Fault Repairs</strong> - Coding errors are cheaper to fix than design or specification errors, which may require significant changes.</li>
          <li><strong>Environmental Adaptation</strong> - This is needed when hardware or software environments change, requiring system adjustments.</li>
          <li><strong>Functionality Addition</strong> - This type is needed when system requirements change due to business or organizational needs.</li>
        </ol></section>

                <p>In practice, there is not a clear-cut distinction between these types of maintenance. When you adapt the system to a new environment, you may add functionality to take advantage of new environmental features. Software faults are often exposed because users use the system in unanticipated ways. Changing the system to accommodate their way of working is the best way to fix these faults.</p>

                <p>These types of maintenance are generally recognized but different people sometimes give them different names. ‘Corrective maintenance’ is universally used to refer to maintenance for fault repair. However, ‘adaptive maintenance’ sometimes means adapting to a new environment and sometimes means adapting the software to new requirements. ‘Perfective maintenance’ sometimes means perfecting the software by implementing new requirements; in other cases it means maintaining the functionality of the system but improving its structure and its performance. Because of this naming uncertainty, I have avoided the use of all of these terms in this chapter.</p>

                <p>There have been several studies of software maintenance which have looked at the relationships between maintenance and development and between different maintenance activities (Krogstie et al., 2005; Lientz and Swanson, 1980; Nosek and Palvia, 1990; Sousa, 1998). Because of differences in terminology, the details of these studies cannot be compared. In spite of changes in technology and different application domains, it seems that there has been remarkably little change in the distribution of evolution effort since the 1980s.</p>

                <p>The surveys broadly agree that software maintenance takes up a higher proportion of IT budgets than new development (roughly two-thirds maintenance, one-third development). They also agree that more of the maintenance budget is spent on implementing new requirements than on fixing bugs. Figure 9.8 shows an approximate distribution of maintenance costs. The specific percentages will obviously vary from one organization to another but, universally, repairing system faults is not the most expensive maintenance activity. Evolving the system to cope with new environments and new or changed requirements consumes most maintenance effort.</p>

                <p>The relative costs of maintenance and new development vary from one application domain to another. Guimaraes (1983) found that the maintenance costs for business application systems are broadly comparable with system development costs.</p>

                <p>These types are not always distinct. Fixing faults may involve adding features, and adapting the system may lead to other changes.</p>
                <img src="1st.PNG.png" alt="">
                
                <h2 class="text-xl font-semibold mt-6 mb-2">Cost Distribution in Software Maintenance</h2>

                
                <p>For embedded real-time systems, maintenance costs were up to four times more than
                    development costs. The high reliability and performance requirements of these systems mean that modules have to be tightly linked and hence difficult to change.
                    Although these estimates are more than 25 years old, it is unlikely that the cost distributions for different types of system have significantly changed.
                    It is usually cost effective to invest effort in designing and implementing a system to
                    reduce the costs of future changes. Adding new functionality after delivery is expensive
                    because you have to spend time learning the system and analyzing the impact of the proposed changes. Therefore, work done during development to make the software easier
                    to understand and change is likely to reduce evolution costs. Good software engineering
                    techniques, such as precise specification, the use of object-oriented development, and
                    configuration management, contribute to maintenance cost reduction.
                    Figure 9.9 shows how overall lifetime costs may decrease as more effort is
                    expended during system development to produce a maintainable system. Because of
                    the potential reduction in costs of understanding, analysis, and testing, there is a significant multiplier effect when the system is developed for maintainability. For
                    System 1, extra development costs of $25,000 are invested in making the system
                    more maintainable. This results in a savings of $100,000 in maintenance costs over</p>
                <img src="2nd.PNG.png" alt="">
                <center><img src="3rd.PNG.png" alt=""></center> 

                <!-- NEW CONTENT STARTS HERE -->
                <p>the lifetime of the system. This assumes that a percentage increase in development
                    costs results in a comparable percentage decrease in overall system costs.
                    These estimates are hypothetical but there is no doubt that developing software to
                    make it more maintainable is cost effective, when the whole life costs of the software
                    are taken into account. This is the rationale for refactoring in agile development.
                    Without refactoring, the code becomes more and more difficult and expensive to
                    change. However, in plan-based development, the reality is that additional investment in code improvement is rarely made during development. This is mostly due to
                    the ways most organizations run their budgets. Investing in maintainability leads to
                    short-term cost increases, which are measurable. Unfortunately, the long-term gains
                    can’t be measured at the same time so companies are reluctant to spend money for an
                    unknown future return.
                </p>
                <p>It is usually more expensive to add functionality after a system is in operation than
                    it is to implement the same functionality during development. The reasons for this are:</p>
                <ol>
                    <li><strong>Team stability</strong> After a system has been delivered, it is normal for the development team to be broken up and for people to work on new projects. The new
                        team or the individuals responsible for system maintenance do not understand
                        the system or the background to system design decisions. They need to spend
                        time understanding the existing system before implementing changes to it.</li>
                    <li><strong>Poor development practice</strong> The contract to maintain a system is usually separate
                        from the system development contract. The maintenance contract may be given
                        to a different company rather than the original system developer. This factor,
                        along with the lack of team stability, means that there is no incentive for a development team to write maintainable software. If a development team can cut corners to save effort during development it is worthwhile for them to do so, even if
                        this means that the software is more difficult to change in the future.</li>
                    <li><strong>Staff skills</strong> Maintenance staff are often relatively inexperienced and unfamiliar with
                        the application domain. Maintenance has a poor image among software engineers.
                        It is seen as a less-skilled process than system development and is often allocated to
                        the most junior staff. Furthermore, old systems may be written in obsolete programming languages. The maintenance staff may not have much experience of development in these languages and must learn these languages to maintain the system.</li>
                    <li><strong>Program age and structure</strong> As changes are made to programs, their structure
                        tends to degrade. Consequently, as programs age, they become harder to understand and change. Some systems have been developed without modern software
                        engineering techniques. They may never have been well structured and were
                        perhaps optimized for efficiency rather than understandability. System documentation may be lost or inconsistent. Old systems may not have been subject to
                        stringent configuration management so time is often wasted finding the right
                        versions of system components to change.</li>
                </ol>
                <p>The first three of these problems stem from the fact that many organizations still
                    consider development and maintenance to be separate activities. Maintenance is seen
                    as a second-class activity and there is no incentive to spend money during development
                    to reduce the costs of system change. The only long-term solution to this problem is to
                    accept that systems rarely have a defined lifetime but continue in use, in some form,
                    for an indefinite period. As I suggested in the introduction, you should think of systems as evolving throughout their lifetime through a continual development process.
                </p>
                <p>The fourth issue, the problem of degraded system structure, is the easiest problem
                    to address. Software reengineering techniques (described later in this chapter) may
                    be applied to improve the system structure and understandability. Architectural
                    transformations can adapt the system to new hardware. Refactoring can improve the
                    quality of the system code and make it easier to change.</p>
                <!-- NEW CONTENT ENDS HERE -->
                 <section> 
        <h2 class="text-xl font-semibold mt-6 mb-2">Reducing Maintenance Costs</h2>
                <p>Investing in designs that reduce future changes is cost-effective. Practices like clear specifications and object-oriented development help lower maintenance costs.</p>
                <p>However, organizations may resist such investments due to budget constraints, especially in plan-based development environments.</p>
            </article>
        </section>
        
        <section id="maintenance-prediction" class="mb-10">
            <article class="article">
                        <h2 class="text-2xl font-semibold mt-4 mb-2">9.3.1 Maintenance Prediction</h2>
                           <p>Managers hate surprises, especially if these result in unexpectedly high costs. You
                            should therefore try to predict what system changes might be proposed and what
                            parts of the system are likely to be the most difficult to maintain. You should also
                            try to estimate the overall maintenance costs for a system in a given time period.
                            Figure 9.10 shows these predictions and associated questions.
                            Predicting the number of change requests for a system requires an understanding
                            of the relationship between the system and its external environment. Some systems
                            have a very complex relationship with their external environment and changes to th
                        </p>
                        <img src="4th.PNG.png" alt="">
                        
                        <p>environment inevitably result in changes to the system. To evaluate the relationships
                        between a system and its environment, you should assess:</p>
                        <ol>
                            <li>The number and complexity of system interfaces. The larger the number of interfaces and the more complex these interfaces, the more likely it is that interface
                            changes will be required as new requirements are proposed.</li>
                            <li>The number of inherently volatile system requirements. As I discussed in Chapter 4,
                            requirements that reflect organizational policies and procedures are likely to be
                            more volatile than requirements that are based on stable domain characteristics.</li>
                            <li>The business processes in which the system is used. As business processes
                            evolve, they generate system change requests. The more business processes that
                            use a system, the more the demands for system change.</li>
                        </ol>
                        
                        <p>For many years, researchers have looked at the relationships between program complexity, as measured by metrics such as cyclomatic complexity (McCabe, 1976), and maintainability (Banker et al., 1993; Coleman et al., 1994; Kafura and Reddy, 1987;
                        Kozlov et al., 2008). It is not surprising that these studies have found that the more
                        complex a system or component, the more expensive it is to maintain. Complexity
                        measurements are particularly useful in identifying program components that are
                        likely to be expensive to maintain. Kafura and Reddy (1987) examined a number of
                        system components and found that maintenance effort tended to be focused on a small
                        number of complex components. To reduce maintenance costs, therefore, you should
                        try to replace complex system components with simpler alternatives.</p>
                
                        <p>After a system has been put into service, you may be able to use process data to
                        help predict maintainability. Examples of process metrics that can be used for
                        assessing maintainability are as follows:</p>
                
                        <ol>
                            <li>Number of requests for corrective maintenance. An increase in the number of
                            bug and failure reports may indicate that more errors are being introduced into
                            the program than are being repaired during the maintenance process. This may
                            indicate a decline in maintainability.</li>
                            <li>Average time required for impact analysis. This reflects the number of program
                            components that are affected by the change request. If this time increases, it implies
                            more and more components are affected and maintainability is decreasing.</li>
                            <li>Average time taken to implement a change request. This is not the same as the
                            time for impact analysis although it may correlate with it. This is the amount of
                            time that you need to modify the system and its documentation, after you have
                            assessed which components are affected. An increase in the time needed to
                            implement a change may indicate a decline in maintainability.</li>
                            <li>Number of outstanding change requests. An increase in this number over time
                            may imply a decline in maintainability.</li>
                        </ol>
                
                        <p>You use predicted information about change requests and predictions about system maintainability to predict maintenance costs. Most managers combine this information with intuition and experience to estimate costs. The COCOMO 2 model of
                        cost estimation (Boehm et al., 2000), discussed in Chapter 24, suggests that an estimate for software maintenance effort can be based on the effort to understand existing code and the effort to develop the new code.</p>
                    </article>
                </section>
                
            </article>
        </section>

        <h2 section id="software-reengineering" class="section">
            <article class="article">
                <h2 class="text-2xl font-semibold mt-4 mb-2">9.3.2 Software Reengineering</h2>
                <p>As I discussed in the previous section, the process of system evolution involves
                    understanding the program that has to be changed and then implementing these
                    changes. However, many systems, especially older legacy systems, are difficult to
                    understand and change. The programs may have been optimized for performance or
                    space utilization at the expense of understandability, or, over time, the initial program structure may have been corrupted by a series of changes.
                    To make legacy software systems easier to maintain, you can reengineer these
                    systems to improve their structure and understandability. Reengineering may involve
                    redocumenting the system, refactoring the system architecture, translating programs
                    to a modern programming language, and modifying and updating the structure and
                    values of the system’s data. The functionality of the software is not changed and,
                    normally, you should try to avoid making major changes to the system architecture.
                    There are two important benefits from reengineering rather than replacement:
                    1. Reduced risk There is a high risk in redeveloping business-critical software.
                    Errors may be made in the system specification or there may be development
                    problems. Delays in introducing the new software may mean that business is
                    lost and extra costs are incurred.</p>
                    <img src="5th.PNG.png" alt="General model of the reengineering process">

<p><strong>2. Reduced cost</strong> The cost of reengineering may be significantly less than the cost
of developing new software. Ulrich (1990) quotes an example of a commercial
system for which the reimplementation costs were estimated at $50 million. The
system was successfully reengineered for $12 million. I suspect that, with modern software technology, the relative cost of reimplementation is probably less
than this but will still considerably exceed the costs of reengineering.</p>

<p>Figure 9.11 is a general model of the reengineering process. The input to the
process is a legacy program and the output is an improved and restructured version
of the same program. The activities in this reengineering process are as follows:</p>

<ol>
    <li><strong>Source code translation</strong> Using a translation tool, the program is converted from
    an old programming language to a more modern version of the same language
    or to a different language.</li>
    <li><strong>Reverse engineering</strong> The program is analyzed and information extracted from it.
    This helps to document its organization and functionality. Again, this process is
    usually completely automated.</li>
    <li><strong>Program structure improvement</strong> The control structure of the program is analyzed and modified to make it easier to read and understand. This can be partially automated but some manual intervention is usually required.</li>
    <li><strong>Program modularization</strong> Related parts of the program are grouped together and,
    where appropriate, redundancy is removed. In some cases, this stage may
    involve architectural refactoring (e.g., a system that uses several different data
    stores may be refactored to use a single repository). This is a manual process.</li>
    <li><strong>Data reengineering</strong> The data processed by the program is changed to reflect
    program changes. This may mean redefining database schemas and converting
    existing databases to the new structure. You should usually also clean up the</li>
</ol>
<img src="6TH.PNG.png" alt="">
<p>
    data. This involves finding and correcting mistakes, removing duplicate records,
etc. Tools are available to support data reengineering.
Program reengineering may not necessarily require all of the steps in Figure 9.11.
You don’t need source code translation if you still use the application’s programming
language. If you can do all reengineering automatically, then recovering documentation through reverse engineering may be unnecessary. Data reengineering is only
required if the data structures in the program change during system reengineering.
To make the reengineered system interoperate with the new software, you may
have to develop adaptor services, as discussed in Chapter 19. These hide the original
interfaces of the software system and present new, better-structured interfaces that
can be used by other components. This process of legacy system wrapping is an
important technique for developing large-scale reusable services.
The costs of reengineering obviously depend on the extent of the work that is
carried out. There is a spectrum of possible approaches to reengineering, as shown
in Figure 9.12. Costs increase from left to right so that source code translation is
the cheapest option. Reengineering as part of architectural migration is the most
expensive.
The problem with software reengineering is that there are practical limits to how
much you can improve a system by reengineering. It isn’t possible, for example, to convert a system written using a functional approach to an object-oriented system. Major
architectural changes or radical reorganizing of the system data management cannot be
carried out automatically, so they are very expensive. Although reengineering can
improve maintainability, the reengineered system will probably not be as maintainable
as a new system developed using modern software engineering methods.
</p>
<section id="preventative-maintenance" class="section">
    <article class="article">
        <h2 class="text-xl font-semibold mt-6 mb-2">9.3.3 Preventative Maintenance by Refactoring</h2>
        <p>Refactoring is the process of making improvements to a program to slow down degradation through change (Opdyke and Johnson, 1990). It means modifying a program to
        improve its structure, to reduce its complexity, or to make it easier to understand.
        Refactoring is sometimes considered to be limited to object-oriented development but
        the principles can be applied to any development approach. When you refactor a program, you should not add functionality but should concentrate on program improvement. You can therefore think of refactoring as ‘preventative maintenance’ that reduces
the problems of future change.</p>

<p>Although reengineering and refactoring are both intended to make software easier
to understand and change, they are not the same thing. Reengineering takes place
after a system has been maintained for some time and maintenance costs are increasing. You use automated tools to process and reengineer a legacy system to create a
new system that is more maintainable. Refactoring is a continuous process of
improvement throughout the development and evolution process. It is intended to
avoid the structure and code degradation that increases the costs and difficulties of
maintaining a system.</p>

<p>Refactoring is an inherent part of agile methods such as extreme programming
because these methods are based around change. Program quality is therefore liable to
degrade quickly so agile developers frequently refactor their programs to avoid this
degradation. The emphasis on regression testing in agile methods lowers the risk of
introducing new errors through refactoring. Any errors that are introduced should be
detectable as previously successful tests should then fail. However, refactoring is not
dependent on other ‘agile activities’ and can be used with any approach to development.</p>

<p>Fowler et al. (1999) suggest that there are stereotypical situations (he calls them
‘bad smells’) in which the code of a program can be improved. Examples of bad
smells that can be improved through refactoring include:</p>
<ol>
    <li><strong>Duplicate code</strong> – The same or very similar code may be included at different
    places in a program. This can be removed and implemented as a single method
    or function that is called as required.</li>
    <li><strong>Long methods</strong> – If a method is too long, it should be redesigned as a number of
    shorter methods.</li>
    <li><strong>Switch (case) statements</strong> – These often involve duplication, where the switch
    depends on the type of some value. The switch statements may be scattered
    around a program. In object-oriented languages, you can often use polymorphism to achieve the same thing.</li>
    <li><strong>Data clumping</strong> – Data clumps occur when the same group of data items (fields in
    classes, parameters in methods) reoccur in several places in a program. These
    can often be replaced with an object encapsulating all of the data.</li>
    <li><strong>Speculative generality</strong> – This occurs when developers include generality in a
    program in case it is required in future. This can often simply be removed.</li>
</ol>

<p>Fowler, in his book and website, also suggests some primitive refactoring transformations that can be used singly or together to deal with the bad smells. Examples
of these transformations include <em>Extract method</em>, where you remove duplication and
create a new method; <em>Consolidate conditional expression</em>, where you replace a
sequence of tests with a single test; and <em>Pull up method</em>, where you replace similar
methods in subclasses with a single method in a super class. Interactive development
environments, such as Eclipse, include refactoring support in their editors. This
makes it easier to find dependent parts of a program that have to be changed to
implement the refactoring.</p>

<p>Refactoring, carried out during program development, is an effective way to
reduce the long-term maintenance costs of a program. However, if you take over a
program for maintenance whose structure has been significantly degraded, then it
may be practically impossible to refactor the code alone. You may also have to think
about design refactoring, which is likely to be a more expensive and difficult problem. Design refactoring involves identifying relevant design patterns (discussed in
Chapter 7) and replacing existing code with code that implements these design patterns (Kerievsky, 2004).</p>
                    
               

    <!-- Footer Section -->
    <footer class="bg-gray-900 text-gray-300 py-6 mt-10">
        <div class="max-w-screen-xl mx-auto px-4 flex flex-col md:flex-row items-center justify-between">
          
          <p class="text-sm">&copy; 2025 <span class="font-semibold text-white">Software Evolution</span>. All rights reserved.</p>
      
        
          <p class="text-sm mt-2 md:mt-0">
            Contact: 
            <span class="text-blue-400">Gonzales</span>, 
            <span class="text-blue-400">Riosa</span>, 
            <span class="text-blue-400">Codizal</span>, 
            <span class="text-blue-400">Villalobos</span>
          </p>
        </div>
      </footer>
</body>

</html>
